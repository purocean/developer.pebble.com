<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Unobstructed Area // Pebble Developers</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta name="description" content="Details on how to use the UnobstructedArea API to adapt your watchface layout
when the screen is partially obstructed by a system overlay.
">
  <link rel="canonical" href="http://developer.getpebble.com/guides/user-interfaces/unobstructed-area/">
  <link href="//fonts.googleapis.com/css?family=Open+Sans:400italic,400,300,600,700" rel="stylesheet" type="text/css">
  <link href="//fonts.googleapis.com/css?family=Inconsolata:400,700" rel="stylesheet" type="text/css">
  <link href="/assets/favicon.png" rel="shortcut icon" type="image/vnd.microsoft.icon" id="favicon">
  <link rel="stylesheet" type="text/css" href="/assets/css/main.css">
  
  <noscript>
  <link rel="stylesheet" type="text/css" href="/assets/css/noscript.css">
  </noscript>
  
  <script type="text/javascript" >
    var _rollbarConfig = {
      accessToken: 'e1ecd52de5ba46c88e9f6f346a954c62',
      captureUncaught: true,
      payload: {
        environment: 'production'
      }
    };
    !function(a,b){function c(b){this.shimId=++h,this.notifier=null,this.parentShim=b,this.logger=function(){},a.console&&void 0===a.console.shimId&&(this.logger=a.console.log)}function d(b,c,d){a._rollbarWrappedError&&(d[4]||(d[4]=a._rollbarWrappedError),d[5]||(d[5]=a._rollbarWrappedError._rollbarContext),a._rollbarWrappedError=null),b.uncaughtError.apply(b,d),c&&c.apply(a,d)}function e(b){var d=c;return g(function(){if(this.notifier)return this.notifier[b].apply(this.notifier,arguments);var c=this,e="scope"===b;e&&(c=new d(this));var f=Array.prototype.slice.call(arguments,0),g={shim:c,method:b,args:f,ts:new Date};return a._rollbarShimQueue.push(g),e?c:void 0})}function f(a,b){if(b.hasOwnProperty&&b.hasOwnProperty("addEventListener")){var c=b.addEventListener;b.addEventListener=function(b,d,e){c.call(this,b,a.wrap(d),e)};var d=b.removeEventListener;b.removeEventListener=function(a,b,c){d.call(this,a,b&&b._wrapped?b._wrapped:b,c)}}}function g(a,b){return b=b||this.logger,function(){try{return a.apply(this,arguments)}catch(c){b("Rollbar internal error:",c)}}}var h=0;c.init=function(a,b){var e=b.globalAlias||"Rollbar";if("object"==typeof a[e])return a[e];a._rollbarShimQueue=[],a._rollbarWrappedError=null,b=b||{};var h=new c;return g(function(){if(h.configure(b),b.captureUncaught){var c=a.onerror;a.onerror=function(){var a=Array.prototype.slice.call(arguments,0);d(h,c,a)};var g,i,j="EventTarget,Window,Node,ApplicationCache,AudioTrackList,ChannelMergerNode,CryptoOperation,EventSource,FileReader,HTMLUnknownElement,IDBDatabase,IDBRequest,IDBTransaction,KeyOperation,MediaController,MessagePort,ModalWindow,Notification,SVGElementInstance,Screen,TextTrack,TextTrackCue,TextTrackList,WebSocket,WebSocketWorker,Worker,XMLHttpRequest,XMLHttpRequestEventTarget,XMLHttpRequestUpload".split(",");for(g=0;g<j.length;++g)i=j[g],a[i]&&a[i].prototype&&f(h,a[i].prototype)}return a[e]=h,h},h.logger)()},c.prototype.loadFull=function(a,b,c,d,e){var f=g(function(){var a=b.createElement("script"),e=b.getElementsByTagName("script")[0];a.src=d.rollbarJsUrl,a.async=!c,a.onload=h,e.parentNode.insertBefore(a,e)},this.logger),h=g(function(){var b;if(void 0===a._rollbarPayloadQueue){var c,d,f,g;for(b=new Error("rollbar.js did not load");c=a._rollbarShimQueue.shift();)for(f=c.args,g=0;g<f.length;++g)if(d=f[g],"function"==typeof d){d(b);break}}"function"==typeof e&&e(b)},this.logger);g(function(){c?f():a.addEventListener?a.addEventListener("load",f,!1):a.attachEvent("onload",f)},this.logger)()},c.prototype.wrap=function(b,c){try{var d;if(d="function"==typeof c?c:function(){return c||{}},"function"!=typeof b)return b;if(b._isWrap)return b;if(!b._wrapped){b._wrapped=function(){try{return b.apply(this,arguments)}catch(c){throw c._rollbarContext=d(),c._rollbarContext._wrappedSource=b.toString(),a._rollbarWrappedError=c,c}},b._wrapped._isWrap=!0;for(var e in b)b.hasOwnProperty(e)&&(b._wrapped[e]=b[e])}return b._wrapped}catch(f){return b}};for(var i="log,debug,info,warn,warning,error,critical,global,configure,scope,uncaughtError".split(","),j=0;j<i.length;++j)c.prototype[i[j]]=e(i[j]);var k="//d37gvrvc0wt4s1.cloudfront.net/js/v1.1/rollbar.min.js";_rollbarConfig.rollbarJsUrl=_rollbarConfig.rollbarJsUrl||k;var l=c.init(a,_rollbarConfig);l.loadFull(a,b,!1,_rollbarConfig)}(window,document);
  </script>
  <script type="text/javascript" async>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-30638158-4', 'auto');
    ga('send', 'pageview');
  </script>
  
</head>
<body class="">
  <div class="mmenu__wrapper">
    <div class="sidebar__wrapper sidebar__wrapper--sectionmenu">
  <div class="sidebar sidebar--narrow">
    <a href="/" class="sidebar__header">
      <span>pebble</span>
    </a>
    <ul class="mainmenu">
      <li class="mainmenu__item mainmenu__item--getting-started"><a href="/tutorials/"><span>Tutorials</span></a></li>
<li class="mainmenu__item mainmenu__item--sdk"><a href="/sdk/"><span>Get the SDK</span></a></li>
<li class="mainmenu__item mainmenu__item--guides active"><a href="/guides/"><span>Guides</span></a></li>
<li class="mainmenu__item mainmenu__item--docs"><a href="/docs/"><span>Documentation</span></a></li>
<li class="mainmenu__item mainmenu__item--examples"><a href="/examples/"><span>Examples</span></a></li>
<li class="mainmenu__item mainmenu__item--community"><a href="/community/"><span>Community</span></a></li>
<li class="mainmenu__item mainmenu__item--blog"><a href="/blog/"><span>Blog</span></a></li>
<li class="mainmenu__item mainmenu__item--more"><a href="/more/"><span>More</span></a></li>

    </ul>
    <div class="sidebar__legal">
      <a href="https://www.pebble.com/legal/privacy/" target="_blank">Privacy</a>
      <br>
      <a href="https://www.pebble.com/legal/cookies/" target="_blank">Cookies</a>
    </div>
    <a href="https://dev-portal.getpebble.com/" target="_blank" class="sidebar__footer">Publish</a>
  </div>
  <div class="section-menu section-menu--guides section-menu--light">
    <div class="section-menu__header">
      <h3><a href="/guides/">Guides</a></h3>
    </div>
    <ul>
      <li class="section-menu__item">
        <a href="/guides/toc/">Table of Contents</a>
      </li>
      
        
        
        
        <li class="section-menu__item">
          <a href="/guides/app-resources/">
            
            App Resources
          </a>
          
        </li>
      
        
        
        
        <li class="section-menu__item">
          <a href="/guides/appstore-publishing/">
            
            Appstore Publishing
          </a>
          
        </li>
      
        
        
        
        <li class="section-menu__item">
          <a href="/guides/best-practices/">
            
            Best Practices
          </a>
          
        </li>
      
        
        
        
        <li class="section-menu__item">
          <a href="/guides/communication/">
            
            Communication
          </a>
          
        </li>
      
        
        
        
        <li class="section-menu__item">
          <a href="/guides/debugging/">
            
            Debugging
          </a>
          
        </li>
      
        
        
        
        <li class="section-menu__item">
          <a href="/guides/design-and-interaction/">
            
            Design and Interaction
          </a>
          
        </li>
      
        
        
        
        <li class="section-menu__item">
          <a href="/guides/events-and-services/">
            
            Events and Services
          </a>
          
        </li>
      
        
        
        
        <li class="section-menu__item">
          <a href="/guides/graphics-and-animations/">
            
            Graphics and Animations
          </a>
          
        </li>
      
        
        
        
        <li class="section-menu__item">
          <a href="/guides/migration/">
            
            Migrating Older Apps
          </a>
          
        </li>
      
        
        
        
        <li class="section-menu__item">
          <a href="/guides/pebble-packages/">
            
            Pebble Packages
          </a>
          
        </li>
      
        
        
        
        <li class="section-menu__item">
          <a href="/guides/pebble-timeline/">
            
            Pebble Timeline
          </a>
          
        </li>
      
        
        
        
        <li class="section-menu__item">
          <a href="/guides/rocky-js/">
            
            Rocky.js
          </a>
          
        </li>
      
        
        
        
        <li class="section-menu__item">
          <a href="/guides/smartstraps/">
            
            Smartstraps
          </a>
          
        </li>
      
        
        
        
        <li class="section-menu__item">
          <a href="/guides/tools-and-resources/">
            
            Tools and Resources
          </a>
          
        </li>
      
        
        
        
        <li class="section-menu__item open">
          <a href="/guides/user-interfaces/">
            
            User Interfaces
          </a>
          
            <ul>
            
            
            
              
                <li class="section-menu__subitem">
                  <a href="/guides/user-interfaces/app-configuration/"><span>App Configuration</span></a>
                </li>
              
            
              
                <li class="section-menu__subitem">
                  <a href="/guides/user-interfaces/app-exit-reason/"><span>App Exit Reason</span></a>
                </li>
              
            
              
                <li class="section-menu__subitem">
                  <a href="/guides/user-interfaces/appglance-c/"><span>AppGlance C API</span></a>
                </li>
              
            
              
                <li class="section-menu__subitem">
                  <a href="/guides/user-interfaces/appglance-rest/"><span>AppGlance REST API</span></a>
                </li>
              
            
              
                <li class="section-menu__subitem">
                  <a href="/guides/user-interfaces/appglance-pebblekit-js/"><span>AppGlance in PebbleKit JS</span></a>
                </li>
              
            
              
                <li class="section-menu__subitem">
                  <a href="/guides/user-interfaces/content-size/"><span>Content Size</span></a>
                </li>
              
            
              
                <li class="section-menu__subitem">
                  <a href="/guides/user-interfaces/layers/"><span>Layers</span></a>
                </li>
              
            
              
                <li class="section-menu__subitem">
                  <a href="/guides/user-interfaces/round-app-ui/"><span>Round App UI</span></a>
                </li>
              
            
              
                <li class="section-menu__subitem active">
                  <a href="/guides/user-interfaces/unobstructed-area/"><span>Unobstructed Area</span></a>
                </li>
              
            
              
            
            
            </ul>
          
        </li>
      
    </ul>
  </div>
</div><!-- sidebar__wrapper -->
<div class="content content--section-menu">
  <div class="search">
  <a  href="javascript:void(0);" class="mobile-nav__hamburger js-mobile-nav-toggle"><i class="fa fa-reorder"></i></a>
  <i class="fa fa-lg fa-search search__icon"></i><input type="search" id="quicksearch" placeholder="Search Developer Site">
</div>
<div class="quicksearch" style="display: none;" id="quicksearch__results"></div>
<div id="search__blackout" style="display: none;"></div>

  <div class="container">
    
<div class="visible-m visible-s visible-xs row">
  <div class="col-xs-12">
    <div class="form__group">
      <div class="select-style no-label">
        <select class="js-toc-select">
          
            <option value="determining-the-unobstructed-bounds">Determining the Unobstructed Bounds</option>
          
            <option value="rendering-with-layerupdateproc">Rendering with LayerUpdateProc</option>
          
            <option value="using-unobstructed-area-handlers">Using Unobstructed Area Handlers</option>
          
            <option value="hiding-layers">- Hiding Layers</option>
          
            <option value="animating-layer-positions">- Animating Layer Positions</option>
          
            <option value="toggling-timeline-quick-view">Toggling Timeline Quick View</option>
          
            <option value="additional-considerations">Additional Considerations</option>
          
        </select>
      </div>
    </div>
  </div>
</div>


<div class="row">
  <div class="col-l-8 col-m-12">
    <h1 class="pagetitle">Unobstructed Area</h1>
    
<!-- 
    
 -->
    <div class="markdown markdown--staff">
    
    <p>The <a href="/docs/c/User_Interface/UnobstructedArea/" title="UnobstructedArea" class="link--docs"><code>UnobstructedArea</code></a> API, added in SDK 4.0, allows developers to dynamically
adapt their watchface design when an area of the screen is partially obstructed
by a system overlay. Currently, the Timeline Quick View feature is the only
system overlay.</p><p>Developers are not required to adjust their designs to cater for such system
overlays, but by using the <a href="/docs/c/User_Interface/UnobstructedArea/" title="UnobstructedArea" class="link--docs"><code>UnobstructedArea</code></a> API they can detect changes to
the available screen real-estate and then move, scale, or hide their layers to
achieve an optimal layout while the screen is partially obscured.</p><p><img src="/assets/images/guides/user-interfaces/unobstructed-area/01-unobstructed-watchfaces.jpg" alt="Unobstructed-watchfaces" />
<p class="blog__image-text">Sample watchfaces with Timeline Quick View overlay
</p></p><p><img src="/assets/images/guides/user-interfaces/unobstructed-area/02-obstructed-watchfaces.jpg" alt="Obstructed-watchfaces" />
<p class="blog__image-text">Potential versions of sample watchfaces using the
UnobstructedArea API</p></p><h3 id="determining-the-unobstructed-bounds" class="anchor">Determining the Unobstructed Bounds</h3><p>Prior to SDK 4.0, when displaying layers on screen you would calculate the
size of the display using <a href="/docs/c/User_Interface/Layers/#layer_get_bounds" title="layer_get_bounds" class="link--docs"><code>layer_get_bounds()</code></a> and then scale and position
your layers accordingly. Developers can now calculate the size of a layer,
excluding system obstructions, using the new
<a href="/docs/c/User_Interface/Layers/#layer_get_unobstructed_bounds" title="layer_get_unobstructed_bounds" class="link--docs"><code>layer_get_unobstructed_bounds()</code></a>.</p><div class="highlight"><pre><span class="k">static</span> <span class="n">Layer</span> <span class="o">*</span><span class="n">s_window_layer</span><span class="p">;</span>
<span class="k">static</span> <span class="n">TextLayer</span> <span class="o">*</span><span class="n">s_text_layer</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">main_window_load</span><span class="p">(</span><span class="n">Window</span> <span class="o">*</span><span class="n">window</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">s_window_layer</span> <span class="o">=</span> <span class="n">window_get_root_layer</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
  <span class="n">GRect</span> <span class="n">unobstructed_bounds</span> <span class="o">=</span> <span class="n">layer_get_unobstructed_bounds</span><span class="p">(</span><span class="n">s_window_layer</span><span class="p">);</span>
  <span class="n">s_text_layer</span> <span class="o">=</span> <span class="n">text_layer_create</span><span class="p">(</span><span class="n">GRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">unobstructed_bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">h</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="n">unobstructed_bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">w</span><span class="p">,</span> <span class="mi">50</span><span class="p">));</span>
<span class="p">}</span>
</pre></div><p>If you still want a fullscreen entities such as a background image, regardless
of any obstructions, just combine both techniques as follows:</p><div class="highlight"><pre><span class="k">static</span> <span class="n">Layer</span> <span class="o">*</span><span class="n">s_window_layer</span><span class="p">;</span>
<span class="k">static</span> <span class="n">BitmapLayer</span> <span class="o">*</span><span class="n">s_image_layer</span><span class="p">;</span>
<span class="k">static</span> <span class="n">TextLayer</span> <span class="o">*</span><span class="n">s_text_layer</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">main_window_load</span><span class="p">(</span><span class="n">Window</span> <span class="o">*</span><span class="n">window</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">s_window_layer</span> <span class="o">=</span> <span class="n">window_get_root_layer</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
  <span class="n">GRect</span> <span class="n">full_bounds</span> <span class="o">=</span> <span class="n">layer_get_bounds</span><span class="p">(</span><span class="n">s_window_layer</span><span class="p">);</span>
  <span class="n">GRect</span> <span class="n">unobstructed_bounds</span> <span class="o">=</span> <span class="n">layer_get_unobstructed_bounds</span><span class="p">(</span><span class="n">s_window_layer</span><span class="p">);</span>
  <span class="n">s_image_layer</span> <span class="o">=</span> <span class="n">bitmap_layer_create</span><span class="p">(</span><span class="n">full_bounds</span><span class="p">);</span>
  <span class="n">s_text_layer</span> <span class="o">=</span> <span class="n">text_layer_create</span><span class="p">(</span><span class="n">GRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">unobstructed_bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">h</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="n">unobstructed_bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">w</span><span class="p">,</span> <span class="mi">50</span><span class="p">));</span>
<span class="p">}</span>
</pre></div><p>The approach outlined above is perfectly fine to use when your watchface is
initially launched, but you’re also responsible for handling the obstruction
appearing and disappearing while your watchface is running.</p><h3 id="rendering-with-layerupdateproc" class="anchor">Rendering with LayerUpdateProc</h3><p>If your application controls its own rendering process using a
<a href="/docs/c/User_Interface/Layers/#LayerUpdateProc" title="LayerUpdateProc" class="link--docs"><code>LayerUpdateProc</code></a> you can just dynamically adjust your rendering
each time your layer updates.</p><p>In this example, we use <a href="/docs/c/User_Interface/Layers/#layer_get_unobstructed_bounds" title="layer_get_unobstructed_bounds" class="link--docs"><code>layer_get_unobstructed_bounds()</code></a> instead of
<a href="/docs/c/User_Interface/Layers/#layer_get_bounds" title="layer_get_bounds" class="link--docs"><code>layer_get_bounds()</code></a>. The graphics are then positioned or scaled based upon
the available screen real-estate, instead of the screen dimensions.</p>
<blockquote>
<p>You must ensure you fill the entire window, not just the unobstructed
area, when drawing the screen - failing to do so may cause unexpected
graphics to be drawn behind the quick view, during animations.</p></blockquote>
<div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">hands_update_proc</span><span class="p">(</span><span class="n">Layer</span> <span class="o">*</span><span class="n">layer</span><span class="p">,</span> <span class="n">GContext</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">GRect</span> <span class="n">bounds</span> <span class="o">=</span> <span class="n">layer_get_unobstructed_bounds</span><span class="p">(</span><span class="n">layer</span><span class="p">);</span>
  <span class="n">GPoint</span> <span class="n">center</span> <span class="o">=</span> <span class="n">grect_center_point</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bounds</span><span class="p">);</span>
  <span class="k">const</span> <span class="kt">int16_t</span> <span class="n">second_hand_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">w</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
  <span class="kt">time_t</span> <span class="n">now</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
  <span class="k">struct</span> <span class="n">tm</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">localtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">now</span><span class="p">);</span>
  <span class="kt">int32_t</span> <span class="n">second_angle</span> <span class="o">=</span> <span class="n">TRIG_MAX_ANGLE</span> <span class="o">*</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">tm_sec</span> <span class="o">/</span> <span class="mi">60</span><span class="p">;</span>
  <span class="n">GPoint</span> <span class="n">second_hand</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int16_t</span><span class="p">)(</span><span class="n">sin_lookup</span><span class="p">(</span><span class="n">second_angle</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="kt">int32_t</span><span class="p">)</span><span class="n">second_hand_length</span> <span class="o">/</span> <span class="n">TRIG_MAX_RATIO</span><span class="p">)</span> <span class="o">+</span> <span class="n">center</span><span class="p">.</span><span class="n">x</span><span class="p">,</span>
    <span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int16_t</span><span class="p">)(</span><span class="o">-</span><span class="n">cos_lookup</span><span class="p">(</span><span class="n">second_angle</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="kt">int32_t</span><span class="p">)</span><span class="n">second_hand_length</span> <span class="o">/</span> <span class="n">TRIG_MAX_RATIO</span><span class="p">)</span> <span class="o">+</span> <span class="n">center</span><span class="p">.</span><span class="n">y</span><span class="p">,</span>
  <span class="p">};</span>

  <span class="c1">// second hand</span>
  <span class="n">graphics_context_set_stroke_color</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">GColorWhite</span><span class="p">);</span>
  <span class="n">graphics_draw_line</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">second_hand</span><span class="p">,</span> <span class="n">center</span><span class="p">);</span>

  <span class="c1">// minute/hour hand</span>
  <span class="n">graphics_context_set_fill_color</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">GColorWhite</span><span class="p">);</span>
  <span class="n">graphics_context_set_stroke_color</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">GColorBlack</span><span class="p">);</span>
  <span class="n">gpath_rotate_to</span><span class="p">(</span><span class="n">s_minute_arrow</span><span class="p">,</span> <span class="n">TRIG_MAX_ANGLE</span> <span class="o">*</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">tm_min</span> <span class="o">/</span> <span class="mi">60</span><span class="p">);</span>
  <span class="n">gpath_draw_filled</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">s_minute_arrow</span><span class="p">);</span>
  <span class="n">gpath_draw_outline</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">s_minute_arrow</span><span class="p">);</span>

  <span class="n">gpath_rotate_to</span><span class="p">(</span><span class="n">s_hour_arrow</span><span class="p">,</span> <span class="p">(</span><span class="n">TRIG_MAX_ANGLE</span> <span class="o">*</span> <span class="p">(((</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">tm_hour</span> <span class="o">%</span> <span class="mi">12</span><span class="p">)</span> <span class="o">*</span> <span class="mi">6</span><span class="p">)</span> <span class="o">+</span>
                  <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">tm_min</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">12</span> <span class="o">*</span> <span class="mi">6</span><span class="p">));</span>
  <span class="n">gpath_draw_filled</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">s_hour_arrow</span><span class="p">);</span>
  <span class="n">gpath_draw_outline</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">s_hour_arrow</span><span class="p">);</span>

  <span class="c1">// dot in the middle</span>
  <span class="n">graphics_context_set_fill_color</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">GColorBlack</span><span class="p">);</span>
  <span class="n">graphics_fill_rect</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">GRect</span><span class="p">(</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">w</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">h</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
  <span class="mi">3</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GCornerNone</span><span class="p">);</span>
<span class="p">}</span>
</pre></div><h3 id="using-unobstructed-area-handlers" class="anchor">Using Unobstructed Area Handlers</h3><p>If you are not overriding the default rendering of a <a href="/docs/c/User_Interface/Layers/#Layer" title="Layer" class="link--docs"><code>Layer</code></a>, you will need to
subscribe to one or more of the <a href="/docs/c/User_Interface/UnobstructedArea/#UnobstructedAreaHandlers" title="UnobstructedAreaHandlers" class="link--docs"><code>UnobstructedAreaHandlers</code></a> to adjust the sizes
and positions of layers.</p><p>There are 3 events available using <a href="/docs/c/User_Interface/UnobstructedArea/#UnobstructedAreaHandlers" title="UnobstructedAreaHandlers" class="link--docs"><code>UnobstructedAreaHandlers</code></a>.
These events will notify you when the unobstructed area is: <em>about to change</em>,
<em>is currently changing</em>, or <em>has finished changing</em>. You can use these handlers
to perform any necessary alterations to your layout.</p><p><code>.will_change</code> - an event to inform you that the unobstructed area size is about
to change. This provides a <a href="/docs/c/Graphics/Graphics_Types/#GRect" title="GRect" class="link--docs"><code>GRect</code></a> which lets you know the size of the screen
after the change has finished.</p><p><code>.change</code> - an event to inform you that the unobstructed area size is currently
changing. This event is called several times during the animation of an
obstruction appearing or disappearing. <a href="/docs/c/User_Interface/Animation/#AnimationProgress" title="AnimationProgress" class="link--docs"><code>AnimationProgress</code></a> is provided to let
you know the percentage of progress towards completion.</p><p><code>.did_change</code> - an event to inform you that the unobstructed area size has
finished changing. This is useful for deinitializing or destroying anything
created or allocated in the will_change handler.</p><p>These handlers are optional, but at least one must be specified for a valid
subscription. In the following example, we subscribe to two of the three
available handlers.</p>
<blockquote>
<p><strong>NOTE</strong>: You must construct the
<a href="/docs/c/User_Interface/UnobstructedArea/#UnobstructedAreaHandlers" title="UnobstructedAreaHandlers" class="link--docs"><code>UnobstructedAreaHandlers</code></a> object <em>before</em> passing it to the
<a href="/docs/c/User_Interface/UnobstructedArea/#unobstructed_area_service_subscribe" title="unobstructed_area_service_subscribe" class="link--docs"><code>unobstructed_area_service_subscribe()</code></a> method.</p></blockquote>
<div class="highlight"><pre><span class="n">UnobstructedAreaHandlers</span> <span class="n">handlers</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">.</span><span class="n">will_change</span> <span class="o">=</span> <span class="n">prv_unobstructed_will_change</span><span class="p">,</span>
  <span class="p">.</span><span class="n">did_change</span> <span class="o">=</span> <span class="n">prv_unobstructed_did_change</span>
<span class="p">};</span>
<span class="n">unobstructed_area_service_subscribe</span><span class="p">(</span><span class="n">handlers</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</pre></div><h4 id="hiding-layers" class="anchor">Hiding Layers</h4><p>In this example, we’re going to hide a <a href="/docs/c/User_Interface/Layers/TextLayer/" title="TextLayer" class="link--docs"><code>TextLayer</code></a> containing the current
date, while the screen is obstructed.</p><p>Just before the Timeline Quick View appears, we’re going to hide the
<a href="/docs/c/User_Interface/Layers/TextLayer/" title="TextLayer" class="link--docs"><code>TextLayer</code></a> and we’ll show it again after the Timeline Quick View disappears.</p><div class="highlight"><pre><span class="k">static</span> <span class="n">Window</span> <span class="o">*</span><span class="n">s_main_window</span><span class="p">;</span>
<span class="k">static</span> <span class="n">Layer</span> <span class="o">*</span><span class="n">s_window_layer</span><span class="p">;</span>
<span class="k">static</span> <span class="n">TextLayer</span> <span class="o">*</span><span class="n">s_date_layer</span><span class="p">;</span>
</pre></div><p>Subscribe to the <code>.did_change</code> and <code>.will_change</code> events:</p><div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">main_window_load</span><span class="p">(</span><span class="n">Window</span> <span class="o">*</span><span class="n">window</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Keep a handle on the root layer</span>
  <span class="n">s_window_layer</span> <span class="o">=</span> <span class="n">window_get_root_layer</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
  <span class="c1">// Subscribe to the will_change and did_change events</span>
  <span class="n">UnobstructedAreaHandlers</span> <span class="n">handlers</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">will_change</span> <span class="o">=</span> <span class="n">prv_unobstructed_will_change</span><span class="p">,</span>
    <span class="p">.</span><span class="n">did_change</span> <span class="o">=</span> <span class="n">prv_unobstructed_did_change</span>
  <span class="p">};</span>
  <span class="n">unobstructed_area_service_subscribe</span><span class="p">(</span><span class="n">handlers</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
</pre></div><p>The <code>will_change</code> event fires before the size of the unobstructed area changes,
so we need to establish whether the screen is already obstructed, or about to
become obstructed. If there isn’t a current obstruction, that means the
obstruction must be about to appear, so we’ll need to hide our data layer.</p><div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">prv_unobstructed_will_change</span><span class="p">(</span><span class="n">GRect</span> <span class="n">final_unobstructed_screen_area</span><span class="p">,</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Get the full size of the screen</span>
  <span class="n">GRect</span> <span class="n">full_bounds</span> <span class="o">=</span> <span class="n">layer_get_bounds</span><span class="p">(</span><span class="n">s_window_layer</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">grect_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">full_bounds</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">final_unobstructed_screen_area</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// Screen is about to become obstructed, hide the date</span>
    <span class="n">layer_set_hidden</span><span class="p">(</span><span class="n">text_layer_get_layer</span><span class="p">(</span><span class="n">s_date_layer</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div><p>The <code>did_change</code> event fires after the unobstructed size changes, so we can
perform the same check to see whether the screen is already obstructed, or
about to become obstructed. If the screen isn’t obstructed when this event
fires, then the obstruction must have just cleared and we’ll need to display
our date layer again.</p><div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">prv_unobstructed_did_change</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Get the full size of the screen</span>
  <span class="n">GRect</span> <span class="n">full_bounds</span> <span class="o">=</span> <span class="n">layer_get_bounds</span><span class="p">(</span><span class="n">s_window_layer</span><span class="p">);</span>
  <span class="c1">// Get the total available screen real-estate</span>
  <span class="n">GRect</span> <span class="n">bounds</span> <span class="o">=</span> <span class="n">layer_get_unobstructed_bounds</span><span class="p">(</span><span class="n">s_window_layer</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">grect_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">full_bounds</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bounds</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// Screen is no longer obstructed, show the date</span>
    <span class="n">layer_set_hidden</span><span class="p">(</span><span class="n">text_layer_get_layer</span><span class="p">(</span><span class="n">s_date_layer</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div><h4 id="animating-layer-positions" class="anchor">Animating Layer Positions</h4><p>The <code>.change</code> event will fire several times while the unobstructed area is
changing size. This allows us to use this event to make our layers appear to
slide-in or slide-out of their initial positions.</p><p>In this example, we’re going to use percentages to position two text layers
vertically. One layer at the top of the screen and one layer at the bottom. When
the screen is obstructed, these two layers will shift to be closer together.
Because we’re using percentages, it doesn’t matter if the unobstructed area is
increasing or decreasing, our text layers will always be relatively positioned
in the available space.</p><div class="highlight"><pre><span class="k">static</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">s_offset_top_percent</span> <span class="o">=</span> <span class="mi">33</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">s_offset_bottom_percent</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</pre></div><p>A simple helper function to simulate percentage based coordinates:</p><div class="highlight"><pre><span class="kt">uint8_t</span> <span class="nf">relative_pixel</span><span class="p">(</span><span class="kt">int16_t</span> <span class="n">percent</span><span class="p">,</span> <span class="kt">int16_t</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">max</span> <span class="o">*</span> <span class="n">percent</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span><span class="p">;</span>
<span class="p">}</span>
</pre></div><p>Subscribe to the change event:</p><div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">main_window_load</span><span class="p">(</span><span class="n">Window</span> <span class="o">*</span><span class="n">window</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">UnobstructedAreaHandlers</span> <span class="n">handler</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">change</span> <span class="o">=</span> <span class="n">prv_unobstructed_change</span>
  <span class="p">};</span>
  <span class="n">unobstructed_area_service_subscribe</span><span class="p">(</span><span class="n">handler</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
</pre></div><p>Move the text layer each time the unobstructed area size changes:</p><div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">prv_unobstructed_change</span><span class="p">(</span><span class="n">AnimationProgress</span> <span class="n">progress</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Get the total available screen real-estate</span>
  <span class="n">GRect</span> <span class="n">bounds</span> <span class="o">=</span> <span class="n">layer_get_unobstructed_bounds</span><span class="p">(</span><span class="n">s_window_layer</span><span class="p">);</span>
  <span class="c1">// Get the current position of our top text layer</span>
  <span class="n">GRect</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">layer_get_frame</span><span class="p">(</span><span class="n">text_layer_get_layer</span><span class="p">(</span><span class="n">s_top_text_layer</span><span class="p">));</span>
  <span class="c1">// Shift the Y coordinate</span>
  <span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">relative_pixel</span><span class="p">(</span><span class="n">s_offset_top_percent</span><span class="p">,</span> <span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">h</span><span class="p">);</span>
  <span class="c1">// Apply the new location</span>
  <span class="n">layer_set_frame</span><span class="p">(</span><span class="n">text_layer_get_layer</span><span class="p">(</span><span class="n">s_top_text_layer</span><span class="p">),</span> <span class="n">frame</span><span class="p">);</span>
  <span class="c1">// Get the current position of our bottom text layer</span>
  <span class="n">GRect</span> <span class="n">frame2</span> <span class="o">=</span> <span class="n">layer_get_frame</span><span class="p">(</span><span class="n">text_layer_get_layer</span><span class="p">(</span><span class="n">s_top_text_layer</span><span class="p">));</span>
  <span class="c1">// Shift the Y coordinate</span>
  <span class="n">frame2</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">relative_pixel</span><span class="p">(</span><span class="n">s_offset_bottom_percent</span><span class="p">,</span> <span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">h</span><span class="p">);</span>
  <span class="c1">// Apply the new position</span>
  <span class="n">layer_set_frame</span><span class="p">(</span><span class="n">text_layer_get_layer</span><span class="p">(</span><span class="n">s_bottom_text_layer</span><span class="p">),</span> <span class="n">frame2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div><h3 id="toggling-timeline-quick-view" class="anchor">Toggling Timeline Quick View</h3><p>The <code>pebble</code> tool which shipped as part of <a href="/sdk4" title="" class="">SDK 4.0</a>,
allows developers to enable and disable Timeline Quick View, which is
incredibly useful for debugging purposes.</p><p><img src="/assets/images/guides/user-interfaces/unobstructed-area/unobstructed-animation.gif" alt="Unobstructed animation" class="pebble-screenshot pebble-screenshot--time-black" /></p><p>To enable Timeline Quick View, you can use:</p><div class="highlight no-copy"><pre>$ pebble emu-set-timeline-quick-view on
</pre></div><p>To disable Timeline Quick View, you can use:</p><div class="highlight no-copy"><pre>$ pebble emu-set-timeline-quick-view off
</pre></div>
<blockquote>
<p><a href="https://cloudpebble.net/" title="" class="">CloudPebble</a> does not currently support toggling
Timeline Quick View, but it will be added as part of a future update.</p></blockquote>
<h3 id="additional-considerations" class="anchor">Additional Considerations</h3><p>If you&#39;re scaling or moving layers based on the unobstructed area, you must
ensure you fill the entire window, not just the unobstructed area. Failing to do
so may cause unexpected graphics to be drawn behind the quick view, during
animations.</p><p>At present, Timeline Quick View is not currently planned for the Chalk platform.</p><p>For design reference, the height of the Timeline Quick View overlay will be
<em>51px</em> in total, which includes a 2px border, but this may vary on newer
platforms and and the height should always be calculated at runtime.</p><div class="highlight"><pre><span class="c1">// Calculate the actual height of the Timeline Quick View</span>
<span class="n">s_window_layer</span> <span class="o">=</span> <span class="n">window_get_root_layer</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
<span class="n">GRect</span> <span class="n">fullscreen</span> <span class="o">=</span> <span class="n">layer_get_bounds</span><span class="p">(</span><span class="n">s_window_layer</span><span class="p">);</span>
<span class="n">GRect</span> <span class="n">unobstructed_bounds</span> <span class="o">=</span> <span class="n">layer_get_unobstructed_bounds</span><span class="p">(</span><span class="n">s_window_layer</span><span class="p">);</span>

<span class="kt">int16_t</span> <span class="n">obstruction_height</span> <span class="o">=</span> <span class="n">fullscreen</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">h</span> <span class="o">-</span> <span class="n">unobstructed_bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">h</span><span class="p">;</span>
</pre></div>
    </div>
    
    <a id="comments" class="anchor"></a>
    <div id="disqus_thread" aria-live="polite" data-post-url="https://developer.getpebble.com/guides/user-interfaces/unobstructed-area/">
      You need JavaScript enabled to read and post comments.
    </div>
    
    
  </div>
  
    <div class="col-m-4 hidden-s hidden-xs hidden-m">
      <div class="gray-box gray-box--fixed gray-box--scrollspy">
        
  <h3>Overview</h3>
  <ul class="toc">
    
      <li class="toc__item toc__item--level1"><a href="#determining-the-unobstructed-bounds">Determining the Unobstructed Bounds</a></li>
    
      <li class="toc__item toc__item--level1"><a href="#rendering-with-layerupdateproc">Rendering with LayerUpdateProc</a></li>
    
      <li class="toc__item toc__item--level1"><a href="#using-unobstructed-area-handlers">Using Unobstructed Area Handlers</a></li>
    
      <li class="toc__item toc__item--level2"><a href="#hiding-layers">Hiding Layers</a></li>
    
      <li class="toc__item toc__item--level2"><a href="#animating-layer-positions">Animating Layer Positions</a></li>
    
      <li class="toc__item toc__item--level1"><a href="#toggling-timeline-quick-view">Toggling Timeline Quick View</a></li>
    
      <li class="toc__item toc__item--level1"><a href="#additional-considerations">Additional Considerations</a></li>
    
  </ul>

        
          <h3>Related SDK Docs</h3>
          <ul>
            
            <li><a href="/docs/c/Graphics/">Graphics</a></li>
            
            <li><a href="/docs/c/User_Interface/Layers/#LayerUpdateProc">LayerUpdateProc</a></li>
            
            <li><a href="/docs/c/User_Interface/UnobstructedArea/">UnobstructedArea</a></li>
            
          </ul>
        
        
          <h3>Examples</h3>
          <ul>
            
            <li><a href="https://github.com/pebble-examples/unobstructed-area-example" target="_blank">Simple Example</a></li>
            
            <li><a href="https://github.com/pebble-examples/watchface-tutorial-unobstructed" target="_blank">Watchface Tutorial</a></li>
            
          </ul>
        
      </div>
    </div>
  
</div>

  </div>
</div>

    
  </div>
  <script type="text/javascript">
    var searchPrimary = '';
  </script>
  
  <script type="text/javascript" src="/assets/js/libs-ce98da7b5eecc97f976a3cad8e665a31.js"></script>
  
  <script type="text/javascript" src="/assets/js/templates.js"></script>
  <script type="text/javascript" src="/assets/js/app.js"></script>
  <script type="text/javascript" src="/assets/js/search.js"></script>
  <script type="text/javascript" src="/assets/js/quicksearch.js"></script>
  <script type="text/javascript" src="/assets/js/disqus.js"></script>
  
</body>
</html>
